\documentclass{article}

\usepackage[a4paper]{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\title{Coding guidelines proposal}
\author{Bart Vandewoestyne}

\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\newenvironment{guideline}{}

\begin{document}
	
\lstset{language=C++,
	backgroundcolor=\color{white},
	basicstyle=\ttfamily,
	showspaces=false,
	showstringspaces=false,
	frame=shadowbox,
	rulesepcolor=\color{blue}}

\maketitle

\tableofcontents

\section{TODO}

Find good references for the following guidelines:
\begin{itemize}
\item Prefer not to call virtual functions in constructors???
\item Don't use void as function arguments, simply leave it out???
\item Prefer not to create threads in constructors???
\item Setting pointers to NULL after deleting them.
\end{itemize}

\section{Comments}

TODO: should comments on a class or method go in the header file or in the source file?

\begin{guideline}
Do not systematically refer to bug numbers in the code comments when you fix a bug.
Reason 1: this should be in the commit message, and the commit message must refer to the bug tracking system.
Reason 2: if bug tracking system changes or is not available, these comments are useless.
\url{http://programmers.stackexchange.com/questions/175309/code-maintenance-to-add-comments-in-code-or-to-just-leave-it-to-the-version-con}
\url{http://programmers.stackexchange.com/questions/146823/is-it-good-practice-to-comment-with-issue-number}
\url{http://programmers.stackexchange.com/questions/228093/good-idea-to-put-bug-numbers-in-a-comment-in-the-beginning-of-the-source-file}
\end{guideline}

\section{Warnings}

Compile with as much warnings as you can.

For Visual C++:
\begin{itemize}
	\item Use /Wall instead of /W1, /W2, /W3 or /W4 because this displays all /W4 warnings and any other warnings that are not included in /W4, for example, warnings that are off by default.
	\item Use /WX to treat compiler warnings as errors.
\end{itemize}

\section{Header files}

\subsection{Order of inclusion}
Header file include order:
\begin{enumerate}
\item include file for corresponding .cpp file
\item include files from current own module
\item include files from other own modules
\item include files from 3rd party modules
\item standard library headers
\item system headers
\end{enumerate}
\url{http://stackoverflow.com/questions/2762568/c-c-include-file-order-best-practices}

\subsection{Include guards}

\begin{guideline}
Include guards should not start with underscores, because such identifiers are officially reserved for the implementation of the compiler and the Standard Library, according to the C++ Standard (ISO/IEC 14882:2003).
\end{guideline}
\begin{itemize}
\item \url{https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Include_Guard_Macro}
\item \url{http://stackoverflow.com/questions/17307540/include-guard-conventions-in-c}
\end{itemize}

\subsection{Don't write namespace usings in a header file or before an include}
See C++ Coding Standards, Chapter 59.

\section{Types}

\begin{itemize}
\item Types definitely should have no more than 50 methods.
See 'Working Effectively with Legacy Code', page 245.
CppDepend even warns when there are more than 20 methods.
\item Types should not have more than 20 fields (CppDepend warns for this).
\end{itemize}

Use the new cast operators \lstinline{static_cast}, \lstinline{const_cast}, \lstinline{reinterpret_cast} and \lstinline{dynamic_cast} instead of old-style C-casts.
Reference: TODO

Direct initialization vs copy initialization (difference for fundamental types vs user-defined types).  Personally, for fundamental types, i prefer
\begin{lstlisting}
int x = 0;
\end{lstlisting}
instead of
\begin{lstlisting}
int x(0);
\end{lstlisting}
For user-defined types, the story is different.  See for example \url{http://www.gotw.ca/gotw/036.htm}.

\section{Control statements}

\begin{itemize}
\item Always use braces in if-statements, to avoid confusion.
\item Reduce scope of local variables as much as possible.  See \url{http://refactoring.com/catalog/reduceScopeOfVariable.html} and \url{http://stackoverflow.com/questions/23604699/cppcheck-the-scope-of-the-variable-can-be-reduced-and-loop}.
\end{itemize}

Always use brace in a for or if statement.  Use
\begin{lstlisting}
for (...)
{
    doSomething();
}
\end{lstlisting}
instead of
\begin{lstlisting}
for (...)
    doSomething();
\end{lstlisting}
Reason: avoid confusion and possible future bugs.

\section{Whitespace}
Use
\begin{lstlisting}
for (...)
{
}
\end{lstlisting}
instead of
\begin{lstlisting}
for(...)
{
}
\end{lstlisting}


\section{Return statements}

Use
\begin{lstlisting}
return x;
\end{lstlisting}
instead of
\begin{lstlisting}
return (x);
\end{lstlisting}
See \url{http://stackoverflow.com/questions/4762662/are-parentheses-around-the-result-significant-in-a-return-statement} and \url{http://stackoverflow.com/questions/161879/parenthesis-surrounding-return-values}.
Reason: it gives the compiler extra work and is not necessary for clarity, so don't use it.

\section{Virtual functions}

\begin{guideline}
Although not strictly necessary, also use the \lstinline{virtual} keyword for your derived-class virtual functions.  It improves readability of the code and `advertises' the fact to the user that the function is virtual.  This is important to anyone further sub-classing the derived class without having to check the base class's definition.
See also \url{http://stackoverflow.com/questions/4895294/c-virtual-keyword-for-functions-in-derived-classes-is-it-necessary}.
\end{guideline}

\section{Subversion}

\begin{itemize}
	\item Create separate commits for code formatting changes.
\end{itemize}

\end{document}
